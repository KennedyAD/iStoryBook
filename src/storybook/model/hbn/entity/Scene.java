/*
 Storybook: Open Source software for novelists and authors.
 Copyright (C) 2008 - 2012 Martin Mustun

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package storybook.model.hbn.entity;

import java.sql.Timestamp;
import java.text.DateFormat;
import java.util.Date;
import java.util.List;

import javax.swing.Icon;

import org.apache.commons.lang3.time.DateUtils;

import storybook.model.state.SceneState;
import storybook.model.state.SceneStateModel;
import storybook.toolkit.DateUtil;
import storybook.toolkit.I18N;
import storybook.toolkit.TextUtil;
import storybook.toolkit.html.HtmlUtil;

// TODO: Auto-generated Javadoc
/**
 * Scene generated by hbm2java.
 *
 * @hibernate.class table="SCENE"
 */
public class Scene extends AbstractEntity implements Comparable<Scene> {

	/** The Constant serialVersionUID. */
	private static final long serialVersionUID = 3808206606478079705L;

	/**
	 * Ts to time.
	 *
	 * @param ts the ts
	 * @return the string
	 */
	public static String tsToTime(Timestamp ts) {
		String r = "";
		// TODO tsToTime for new calendar
		return (r);
	}
	
	/** The chapter. */
	private Chapter chapter;
	
	/** The strand. */
	private Strand strand;
	
	/** The sceneno. */
	private Integer sceneno;
	
	/** The scene ts. */
	private Timestamp sceneTs;
	
	/** The title. */
	private String title;
	
	/** The summary. */
	private String summary;
	
	/** The status. */
	private Integer status;
	
	/** The relative date difference. */
	private Integer relativeDateDifference;
	
	/** The relative scene id. */
	private Long relativeSceneId;
	
	/** The notes. */
	private String notes;
	
	/** The odf. */
	private String odf;

	/** The informative. */
	private Boolean informative;
	
	/** The persons. */
	private List<Person> persons;
	
	/** The items. */
	private List<Item> items;
	
	/** The locations. */
	private List<Location> locations;

	/** The strands. */
	private List<Strand> strands;

	/**
	 * Instantiates a new scene.
	 */
	public Scene() {
		super();
	}

	/**
	 * Instantiates a new scene.
	 *
	 * @param chapter the chapter
	 * @param strand the strand
	 * @param sceneno the sceneno
	 * @param date the date
	 * @param title the title
	 * @param summary the summary
	 * @param status the status
	 * @param relativeDateDifference the relative date difference
	 * @param relativeSceneId the relative scene id
	 * @param notes the notes
	 * @param informative the informative
	 * @param odf the odf
	 */
	public Scene(Chapter chapter, Strand strand, Integer sceneno, Timestamp date, String title, String summary,
			Integer status, Integer relativeDateDifference, Long relativeSceneId, String notes, Boolean informative,
			String odf) {
		this.chapter = chapter;
		this.strand = strand;
		this.sceneno = sceneno;
		this.sceneTs = date;
		this.title = title;
		this.summary = summary;
		this.status = status;
		this.relativeDateDifference = relativeDateDifference;
		this.relativeSceneId = relativeSceneId;
		this.notes = notes;
		this.informative = informative;
		this.odf = odf;
	}

	/* (non-Javadoc)
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 */
	@Override
	public int compareTo(Scene o) {
		int cmp = chapter.compareTo(o.chapter);
		if (cmp == 0) {
			return sceneno.compareTo(o.sceneno);
		}
		return cmp;
	}

	/* (non-Javadoc)
	 * @see storybook.model.hbn.entity.AbstractEntity#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if (!super.equals(obj)) {
			return false;
		}
		Scene test = (Scene) obj;

		if (id != null ? !id.equals(test.id) : test.id != null) {
			return false;
		}
		boolean ret = true;
		ret = ret && equalsIntegerNullValue(sceneno, test.getSceneno());
		ret = ret && equalsIntegerNullValue(status, test.getStatus());
		ret = ret && equalsObjectNullValue(chapter, test.getChapter());
		ret = ret && equalsObjectNullValue(strand, test.getStrand());
		if (sceneTs != null) {
			ret = ret && equalsTimestampNullValue(sceneTs, test.getSceneTs());
		} else if (relativeSceneId != null) {
			ret = ret && equalsLongNullValue(relativeSceneId, test.getRelativeSceneId());
			ret = ret && equalsIntegerNullValue(relativeDateDifference, test.getRelativeDateDifference());
		}
		ret = ret && equalsStringNullValue(title, test.getTitle());
		ret = ret && equalsStringNullValue(summary, test.getSummary());
		ret = ret && equalsStringNullValue(notes, test.getNotes());
		ret = ret && equalsBooleanNullValue(informative, test.getInformative());
		ret = ret && equalsListNullValue(persons, test.getPersons());
		ret = ret && equalsListNullValue(locations, test.getLocations());
		ret = ret && equalsListNullValue(strands, test.getStrands());
		return ret;
	}

	/**
	 * Gets the calendar.
	 *
	 * @return the calendar
	 */
	public String getCalendar() {
		String r = "";
		if (notes.startsWith("$£€ø")) {
			String z[] = notes.split("ø€£$");
			String y[] = z[0].split("**");
			r = y[0].substring("$£€ø".length());
		}
		return (r);
	}

	/**
	 * Gets the chapter.
	 *
	 * @return the chapter
	 */
	public Chapter getChapter() {
		return this.chapter;
	}

	/**
	 * Gets the chapter scene no.
	 *
	 * @return the chapter scene no
	 */
	public String getChapterSceneNo() {
		return getChapterSceneNo(true);
	}

	/**
	 * Gets the chapter scene no.
	 *
	 * @param appendColon the append colon
	 * @return the chapter scene no
	 */
	public String getChapterSceneNo(boolean appendColon) {
		StringBuilder buf = new StringBuilder();
		if (hasChapter()) {
			buf.append(chapter.getChapterno());
		} else {
			buf.append("x");
		}
		buf.append(".");
		if (hasSceneno()) {
			buf.append(sceneno);
		} else {
			buf.append("x");
		}
		if (appendColon) {
			buf.append(": ");
		}
		return buf.toString();
	}

	/**
	 * Gets the chapter scene tool tip.
	 *
	 * @return the chapter scene tool tip
	 */
	public String getChapterSceneToolTip() {
		if (!hasChapter()) {
			return "";
		}
		StringBuilder buf = new StringBuilder("<html>");
		buf.append(I18N.getMsgColon("msg.common.chapter"));
		buf.append(" ").append(getChapter().toString());
		buf.append("<br>");
		if (getChapter().hasPart()) {
			buf.append(I18N.getMsgColon("msg.common.part"));
			buf.append(" ").append(getChapter().getPart().toString());
			buf.append("<br>");
		}
		return buf.toString();
	}

	/**
	 * Gets the date.
	 *
	 * @return the date
	 */
	public Date getDate() {
		if (sceneTs == null) {
			return null;
		}
		// OLD: return new Date(sceneTs.getTime());
		// remove time from date
		return DateUtil.getZeroTimeDate(new Date(sceneTs.getTime()));
	}

	/**
	 * Gets the date str long.
	 *
	 * @return the date str long
	 */
	public String getDateStrLong() {
		if (!hasSceneTs()) {
			return "";
		}
		DateFormat formatter;
		if (DateUtil.isZeroTimeDate(sceneTs)) {
			formatter = I18N.getLongDateFormatter();
		} else {
			formatter = I18N.getDateTimeFormatter();
		}
		return formatter.format(sceneTs);
	}

	/**
	 * Gets the date str medium.
	 *
	 * @return the date str medium
	 */
	public String getDateStrMedium() {
		if (!hasSceneTs()) {
			return "";
		}
		DateFormat formatter;
		if (DateUtil.isZeroTimeDate(sceneTs)) {
			formatter = I18N.getMediumDateFormatter();
		} else {
			formatter = I18N.getDateTimeFormatter();
		}
		return formatter.format(sceneTs);
	}

	/**
	 * Gets the date str short.
	 *
	 * @return the date str short
	 */
	public String getDateStrShort() {
		if (!hasSceneTs()) {
			return "";
		}
		DateFormat formatter;
		if (DateUtil.isZeroTimeDate(sceneTs)) {
			formatter = I18N.getShortDateFormatter();
		} else {
			formatter = I18N.getDateTimeFormatter();
		}
		return formatter.format(sceneTs);
	}

	/**
	 * Gets the full title.
	 *
	 * @return the full title
	 */
	public String getFullTitle() {
		return getFullTitle(false);
	}

	/**
	 * Gets the full title.
	 *
	 * @param truncate the truncate
	 * @return the full title
	 */
	public String getFullTitle(boolean truncate) {
		return getFullTitle(false, truncate);
	}

	/**
	 * Gets the full title.
	 *
	 * @param timestamp the timestamp
	 * @param truncate the truncate
	 * @return the full title
	 */
	public String getFullTitle(boolean timestamp, boolean truncate) {
		StringBuilder buf = new StringBuilder();
		buf.append(getChapterSceneNo());
		buf.append(getTitle(truncate));
		if (timestamp && hasSceneTs()) {
			buf.append(" (");
			buf.append(getDateStrMedium());
			buf.append(")");
		}
		return buf.toString();
	}

	/* (non-Javadoc)
	 * @see storybook.model.hbn.entity.AbstractEntity#getIcon()
	 */
	@Override
	public Icon getIcon() {
		return I18N.getIcon("icon.small.scene");
	}

	/* (non-Javadoc)
	 * @see storybook.model.hbn.entity.AbstractEntity#getId()
	 */
	@Override
	public Long getId() {
		return this.id;
	}

	/**
	 * Gets the informative.
	 *
	 * @return the informative
	 */
	public Boolean getInformative() {
		if (informative == null) {
			return false;
		}
		return informative;
	}

	/**
	 * Gets the items.
	 *
	 * @return the items
	 */
	public List<Item> getItems() {
		return items;
	}

	/**
	 * Gets the locations.
	 *
	 * @return the locations
	 */
	public List<Location> getLocations() {
		return locations;
	}

	/**
	 * Gets the no scene ts.
	 *
	 * @return the no scene ts
	 */
	public void getNoSceneTs() {
		// nothing to do
	}

	/**
	 * Gets the notes.
	 *
	 * @return the notes
	 */
	public String getNotes() {
		return getNotes(false);
	}

	/**
	 * Gets the notes.
	 *
	 * @param truncate the truncate
	 * @return the notes
	 */
	public String getNotes(boolean truncate) {
		if (this.notes == null) {
			return "";
		}
		String x = this.notes;
		if (notes.startsWith("<SB4")) {
			String z[] = notes.split("</SB4>");
			x = z[1];
		}
		if (truncate) {
			x = TextUtil.truncateString(HtmlUtil.htmlToText(x), 200);
		}
		return (x);
	}

	/**
	 * Gets the odf.
	 *
	 * @return the odf
	 */
	public String getOdf() {
		return (odf);
	}

	/**
	 * Gets the part chapter scene no.
	 *
	 * @return the part chapter scene no
	 */
	public String getPartChapterSceneNo() {
		String ret = "";
		if (!hasChapter()) {
			ret = "x.x.";
		} else {
			ret = chapter.getPart().getNumber() + "." + chapter.getChapterno() + ".";
		}
		ret += sceneno;
		return (ret);
	}

	/**
	 * Gets the persons.
	 *
	 * @return the persons
	 */
	public List<Person> getPersons() {
		return persons;
	}

	/**
	 * Gets the relative date.
	 *
	 * @param relativeScene the relative scene
	 * @return the relative date
	 */
	public Date getRelativeDate(Scene relativeScene) {
		if (relativeScene == null) {
			return null;
		}
		Date date = relativeScene.getDate();
		if (date == null) {
			return null;
		}
		return DateUtils.addDays(date, relativeDateDifference);
	}

	/**
	 * Gets the relative date difference.
	 *
	 * @return the relative date difference
	 */
	public Integer getRelativeDateDifference() {
		return this.relativeDateDifference;
	}

	/**
	 * Gets the relative scene id.
	 *
	 * @return the relative scene id
	 */
	public Long getRelativeSceneId() {
		return this.relativeSceneId;
	}

	/**
	 * Gets the sceneno.
	 *
	 * @return the sceneno
	 */
	public Integer getSceneno() {
		return this.sceneno;
	}

	/**
	 * Gets the scene state.
	 *
	 * @return the scene state
	 */
	public SceneState getSceneState() {
		SceneStateModel model = new SceneStateModel();
		return (SceneState) model.findByNumber(this.status);
	}

	/**
	 * Gets the scene time.
	 *
	 * @return the scene time
	 */
	public String getSceneTime() {
		// TODO getSceneTime for new calendar
		String r = "";
		return (r);
	}

	/**
	 * Gets the scene ts.
	 *
	 * @return the scene ts
	 */
	public Timestamp getSceneTs() {
		return this.sceneTs;
	}

	/**
	 * Gets the status.
	 *
	 * @return the status
	 */
	public Integer getStatus() {
		return this.status;
	}

	/**
	 * Gets the status icon.
	 *
	 * @return the status icon
	 */
	public Icon getStatusIcon() {
		return getSceneState().getIcon();
	}

	/**
	 * Gets the strand.
	 *
	 * @return the strand
	 */
	public Strand getStrand() {
		return this.strand;
	}

	/**
	 * Gets the strands.
	 *
	 * @return the strands
	 */
	public List<Strand> getStrands() {
		return strands;
	}

	/**
	 * Gets the summary.
	 *
	 * @return the summary
	 */
	public String getSummary() {
		return this.summary;
	}

	/**
	 * Gets the summary.
	 *
	 * @param truncate the truncate
	 * @param length the length
	 * @return the summary
	 */
	public String getSummary(boolean truncate, int length) {
		if (truncate) {
			return TextUtil.truncateString(HtmlUtil.htmlToText(summary), length);
		}
		return this.summary;
	}

	/**
	 * Gets the text.
	 *
	 * @return the text
	 */
	public String getText() {
		return getSummary();
	}

	/**
	 * Gets the text.
	 *
	 * @param truncate the truncate
	 * @param length the length
	 * @return the text
	 */
	public String getText(boolean truncate, int length) {
		return getSummary(truncate, length);
	}

	/**
	 * Gets the title.
	 *
	 * @return the title
	 */
	public String getTitle() {
		return title;
	}

	/**
	 * Gets the title.
	 *
	 * @param truncate the truncate
	 * @return the title
	 */
	public String getTitle(boolean truncate) {
		if (truncate) {
			return TextUtil.ellipsize(title, 30);
		}
		return title;
	}

	/**
	 * Gets the title text.
	 *
	 * @param truncate the truncate
	 * @param length the length
	 * @return the title text
	 */
	public String getTitleText(boolean truncate, int length) {
		if (title == null || title.isEmpty()) {
			return getText(truncate, length);
		}
		return getTitle(truncate) + ": " + getText(truncate, length);
	}

	/**
	 * Checks for chapter.
	 *
	 * @return true, if successful
	 */
	public boolean hasChapter() {
		return chapter != null;
	}

	/* (non-Javadoc)
	 * @see storybook.model.hbn.entity.AbstractEntity#hashCode()
	 */
	@Override
	public int hashCode() {
		int hash = super.hashCode();
		hash = hash * 31 + (sceneno != null ? sceneno.hashCode() : 0);
		hash = hash * 31 + (status != null ? status.hashCode() : 0);
		hash = hash * 31 + (chapter != null ? chapter.hashCode() : 0);
		hash = hash * 31 + (strand != null ? strand.hashCode() : 0);
		hash = hash * 31 + (sceneTs != null ? sceneTs.hashCode() : 0);
		hash = hash * 31 + (relativeSceneId != null ? relativeSceneId.hashCode() : 0);
		hash = hash * 31 + (relativeDateDifference != null ? relativeDateDifference.hashCode() : 0);
		hash = hash * 31 + (title != null ? title.hashCode() : 0);
		hash = hash * 31 + (summary != null ? summary.hashCode() : 0);
		hash = hash * 31 + (notes != null ? notes.hashCode() : 0);
		hash = hash * 31 + (informative != null ? informative.hashCode() : 0);
		hash = hash * 31 + (persons != null ? getListHashCode(persons) : 0);
		hash = hash * 31 + (locations != null ? getListHashCode(locations) : 0);
		hash = hash * 31 + (strands != null ? getListHashCode(strands) : 0);
		return hash;
	}

	/**
	 * Checks for no scene ts.
	 *
	 * @return true, if successful
	 */
	public boolean hasNoSceneTs() {
		return sceneTs == null;
	}

	/**
	 * Checks for relative scene.
	 *
	 * @return true, if successful
	 */
	public boolean hasRelativeScene() {
		return this.relativeSceneId != null;
	}

	/**
	 * Checks for sceneno.
	 *
	 * @return true, if successful
	 */
	public boolean hasSceneno() {
		return sceneno != null;
	}

	/**
	 * Checks for scene ts.
	 *
	 * @return true, if successful
	 */
	public boolean hasSceneTs() {
		return sceneTs != null;
	}

	/**
	 * Number of characters.
	 *
	 * @return the int
	 */
	public int numberOfCharacters() {
		int nb = HtmlUtil.htmlToText(summary).length();
		return (nb);
	}

	/**
	 * Number of words.
	 *
	 * @return the int
	 */
	public int numberOfWords() {
		int nb = TextUtil.countWords(summary);
		return (nb);
	}

	/**
	 * Removes the no scene ts.
	 */
	public void removeNoSceneTs() {
		// nothing to do
	}

	/**
	 * Removes the relative scene.
	 */
	public void removeRelativeScene() {
		relativeSceneId = null;
		relativeDateDifference = null;
	}

	/**
	 * Removes the scene ts.
	 */
	public void removeSceneTs() {
		sceneTs = null;
	}

	/**
	 * Sets the calendar.
	 *
	 * @param cal the new calendar
	 */
	public void setCalendar(String cal) {
		/*
		 * String r = ""; if (notes.startsWith("$£€ø")) { String nf = getODF();
		 * String nt = getNotesNew(); notes = "$£€ø" + cal + "**" + nf + "ø€£$"
		 * + nt; } else { String nf = ""; notes = "$£€ø" + cal + "**" + nf +
		 * "ø€£$" + notes; }
		 */
	}

	/**
	 * Sets the chapter.
	 */
	public void setChapter() {
		this.chapter = null;
	}

	/**
	 * Sets the chapter.
	 *
	 * @param chapter the new chapter
	 */
	public void setChapter(Chapter chapter) {
		this.chapter = chapter;
	}

	/**
	 * Sets the date.
	 *
	 * @param date the new date
	 */
	public void setDate(Date date) {
		if (date == null) {
			sceneTs = null;
			return;
		}
		sceneTs = new Timestamp(date.getTime());
	}

	/**
	 * Sets the id.
	 *
	 * @param id the new id
	 */
	public void setId(Long id) {
		this.id = id;
	}

	/**
	 * Sets the informative.
	 *
	 * @param informative the new informative
	 */
	public void setInformative(Boolean informative) {
		this.informative = informative;
	}

	/**
	 * Sets the items.
	 *
	 * @param items the new items
	 */
	public void setItems(List<Item> items) {
		this.items = items;
	}

	/**
	 * Sets the locations.
	 *
	 * @param locations the new locations
	 */
	public void setLocations(List<Location> locations) {
		this.locations = locations;
	}

	/**
	 * Sets the no scene ts.
	 */
	public void setNoSceneTs() {
		// nothing to do
	}

	/**
	 * Sets the no scene ts.
	 *
	 * @param val the new no scene ts
	 */
	public void setNoSceneTs(String val) {
		// nothing to do
	}

	/**
	 * Sets the notes.
	 *
	 * @param notes the new notes
	 */
	public void setNotes(String notes) {
		this.notes = notes;
	}

	/**
	 * Sets the odf.
	 *
	 * @param nf the new odf
	 */
	public void setOdf(String nf) {
		odf = nf;
	}

	/**
	 * Sets the persons.
	 *
	 * @param persons the new persons
	 */
	public void setPersons(List<Person> persons) {
		this.persons = persons;
	}

	/**
	 * Sets the relative date difference.
	 *
	 * @param relativeDateDifference the new relative date difference
	 */
	public void setRelativeDateDifference(Integer relativeDateDifference) {
		this.relativeDateDifference = relativeDateDifference;
	}

	/**
	 * Sets the relative scene id.
	 *
	 * @param relativeSceneId the new relative scene id
	 */
	public void setRelativeSceneId(Long relativeSceneId) {
		this.relativeSceneId = relativeSceneId;
	}

	/**
	 * Sets the relative scene id.
	 *
	 * @param relativeScene the new relative scene id
	 */
	public void setRelativeSceneId(Scene relativeScene) {
		if (relativeScene == null) {
			return;
		}
		setRelativeSceneId(relativeScene.id);
	}

	/**
	 * Sets the sceneno.
	 *
	 * @param sceneno the new sceneno
	 */
	public void setSceneno(Integer sceneno) {
		this.sceneno = sceneno;
	}

	/**
	 * Sets the scene state.
	 *
	 * @param state the new scene state
	 */
	public void setSceneState(SceneState state) {
		this.status = state.getNumber();
	}

	/**
	 * Sets the scene time.
	 *
	 * @param t the new scene time
	 */
	public void setSceneTime(String t) {
		// TODO setSceneTime
	}

	/**
	 * Sets the scene ts.
	 *
	 * @param ts the new scene ts
	 */
	public void setSceneTs(Timestamp ts) {
		sceneTs = ts;
	}

	/**
	 * Sets the status.
	 *
	 * @param status the new status
	 */
	public void setStatus(Integer status) {
		this.status = status;
	}

	/**
	 * Sets the strand.
	 *
	 * @param strand the new strand
	 */
	public void setStrand(Strand strand) {
		this.strand = strand;
	}

	/**
	 * Sets the strands.
	 *
	 * @param strands the new strands
	 */
	public void setStrands(List<Strand> strands) {
		this.strands = strands;
	}

	/**
	 * Sets the summary.
	 *
	 * @param summary the new summary
	 */
	public void setSummary(String summary) {
		this.summary = summary;
	}

	/*
	 * public String sceneNotesConversion(Scene scene) { String n =
	 * scene.getNotes(); if (!n.startsWith("$£€ø")) { n = "$£€ø" + "**" + "ø€£$"
	 * + getNotes(); } return (n); }
	 */

	/**
	 * Sets the title.
	 *
	 * @param title the new title
	 */
	public void setTitle(String title) {
		this.title = title;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		if (isTransient()) {
			// return I18N.getMsg("msg.common.scene") + " [" + getTransientId()
			// + "]";
			return "";
		}
		return getFullTitle(false, true);
	}
}
